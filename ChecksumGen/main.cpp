// A20 Checksum Generator for Windows.
// by Mike Kaiser (11 Dec 2014) [no additional copyright from me. It's trivial stuff so take it and do what you like with it]
// This code has been inspired by many of the internet forum posts and GPL / LGPL code out there on various forums.
//
// The source of the header definition is directly from sunxi-tools/bootinfo.c
// (C) Copyright 2012 Henrik Nordstrom <henrik@henriknordstrom.net>
//
// Thanks go to Goatfreed on Cubieforums for posting his test program and instructions on how to get it running.
// Thanks to baremetal for suggesting a boot sector to stop windows bringing up an 'unformated' dialog.
// This code is provided without warranty and does not claim to be bug free or fit for any purpose. Use it at your own risk.


#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <Windows.h>
#include <cstdint>

typedef unsigned char  u8;
typedef unsigned short u16;
typedef unsigned int   u32;

typedef signed char  s8;
typedef signed short s16;
typedef signed int   s32;

class Buffer
{
	int bufLen;
	u8 * buf;

public:
	Buffer()
		: bufLen(0)
		, buf( nullptr )
	{
	}

	~Buffer()
	{
		if (buf)
			free(buf);
	}

	void Read(FILE * fp)
	{
		fseek(fp, 0, SEEK_END);
		bufLen = ftell(fp);
		fseek(fp, 0, SEEK_SET);
		buf = (u8 *)realloc(buf, bufLen);
		fread(buf, 1, bufLen, fp);
	}

	void Write(FILE * fp, int padSize)
	{
		char pad = 0;
		for (int i = 0; i < padSize; ++i)
			fwrite(&pad, 1, 1, fp);
		fwrite(buf, 1, bufLen, fp);
	}

	int WriteFATHeader(FILE * fp)
	{
		// This writes a bare minimum boot sector to fool windows into thinking it has a valid FAT16 disk
		u8 header[] =
		{
			// Jump
			0xEB, 0x3C, 0x90,
			
			// OEM ID
			0x4D, 0x53, 0x44, 0x4F, 0x53, 0x35, 0x2E, 0x30,

			// BPB and EBPB
			0x00, 0x02, 0x08, 0x04, 0x00, 0x02, 0x00, 0x02,	0x00, 0x00, 0xF8, 0xEE, 0x00, 0x3F, 0x00, 0xFF,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x07,	0x00, 0x80, 0x00, 0x29, 0x80, 0xE1, 0x4B, 0x38,
			0x4E, 0x4F, 0x20, 0x4E, 0x41, 0x4D, 0x45, 0x20,	0x20, 0x20, 0x20, 0x46, 0x41, 0x54, 0x31, 0x36,
			0x20, 0x20, 0x20, 0x33, 0xC9, 0x8E, 0xD1, 0xBC,	0xF0, 0x7B, 0x8E, 0xD9, 0xB8, 0x00, 0x20, 0x8E,
			0xC0, 0xFC, 0xBD, 0x00, 0x7C, 0x38, 0x4E, 0x24, 0x7D
		};

		fwrite(header, 1, sizeof(header), fp);

		for (int i = 0; i < 426; ++i)		// this would be were the code for the DOS boot sector would live but we just zero it out
			fputc(0, fp);

		fputc(0x55, fp);
		fputc(0xAA, fp);
		return 512;
	}

	void SetBufSize( int newSize )
	{
		int oldLen = bufLen;
		bufLen = newSize;
		buf = (u8*)realloc(buf, newSize);
		for (int i = oldLen; i < bufLen; ++i)
			buf[i] = 0xFF;
	}

	void * GetBaseAddr() const
	{
		return buf;
	}

	void * GetEndAddr() const
	{
		return buf + bufLen;
	}

	int GetSize() const
	{
		return bufLen;
	}
};




struct Header
{
	u32		jump_instruction;	// one instruction jumping to real code
	char	magic[8];			// ="eGON.BT0" or "eGON.BT1", not C-style string.
	u32		check_sum;			// generated by PC
	u32		length;				// specified in your startup ASM
	u32		pub_head_size;		// the size of boot_file_head_t
	u8		pub_head_vsn[4];	// the version of boot_file_head_t
	u8		file_head_vsn[4];	// the version of boot0_file_head_t or boot1_file_head_t
	u8		Boot_vsn[4];		// Boot version
	u8		eGON_vsn[4];		// eGON version
	u8		platform[8];		// platform information
};



u32 ComputeCheckSum(const Buffer & src)
{
	u32 checksum = 0;
	u32 * ptr = (u32 *)(src.GetBaseAddr());
	u32 * end = (u32 *)(src.GetEndAddr());

	while(ptr < end)
	{
		checksum += *(ptr++);	// I'm sure there should be some bigendian / littleendian swapping going on here but it seems to work all the same. <Shrug>
	}

	return checksum;
}




// https://docs.microsoft.com/en-us/answers/questions/302450/how-to-write-to-sector-0-mbr-of-sd-card.html
// https://stackoverflow.com/questions/6608466/how-to-writefile-to-a-physicaldrive-windows-7-without-getting-error-access-den
// https://stackoverflow.com/questions/64018265/writing-usb-disk-sectors-results-in-permission-error-5
HANDLE SDCardOpen(const char* drive_name)
{
	char   dev_name[128];
	BOOL   bResult;
	HANDLE hDevice;
	DWORD  BytesReturned;
	VOLUME_DISK_EXTENTS vde;

	// drive_name example : "D:"

	sprintf(dev_name, "\\\\.\\%s", drive_name);
	hDevice = CreateFileA(dev_name,             // Drive to open
		GENERIC_READ | GENERIC_WRITE,          // Access to the drive
		FILE_SHARE_READ | FILE_SHARE_WRITE,    // Share mode
		NULL,                                  // Security
		OPEN_EXISTING,                         // Disposition
		0,                                     // no file attributes
		NULL);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("Can't open the drive %s (err = %d).\n", drive_name, GetLastError());
		return INVALID_HANDLE_VALUE;
	}

	bResult = DeviceIoControl(hDevice, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, NULL, 0, &vde, sizeof(vde), &BytesReturned, NULL);
	if (!bResult)
	{
		printf("Failed to get physical disk name (err = %d).\n", GetLastError());
		return INVALID_HANDLE_VALUE;
	}

	bResult = DeviceIoControl(hDevice, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, &BytesReturned, NULL);
	if (!bResult)
	{
		printf("Unable to unmount volume (err = %d).\n", GetLastError());
		return INVALID_HANDLE_VALUE;
	}

	bResult = DeviceIoControl(hDevice, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0, &BytesReturned, NULL);
	if (!bResult)
	{
		int err = GetLastError();
		if (err != 158)
		{
			printf("Unable to lock volume (err = %d).\n", GetLastError());
			return INVALID_HANDLE_VALUE;
		}
	}

	CloseHandle(hDevice);


	// Reopen the disk as a physical disk rather than a logical one
	sprintf(dev_name, "\\\\.\\PhysicalDrive%d", vde.Extents[0].DiskNumber);

	hDevice = CreateFileA(dev_name,            // Drive to open
		GENERIC_READ | GENERIC_WRITE,          // Access to the drive
		FILE_SHARE_READ | FILE_SHARE_WRITE,    // Share mode
		NULL,                                  // Security
		OPEN_EXISTING,                         // Disposition
		0,                                     // no file attributes
		NULL);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("Can't open the disk %s (err = %d).\n", dev_name, GetLastError());
		return INVALID_HANDLE_VALUE;
	}

	bResult = DeviceIoControl(hDevice, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0, &BytesReturned, NULL);
	if (!bResult)
	{
		printf("Failed to lock volume (err = %d).\n", GetLastError());
		return INVALID_HANDLE_VALUE;
	}

	bResult = DeviceIoControl(hDevice, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, &BytesReturned, NULL);
	if (!bResult)
	{
		printf("Failed to dismount volume (err = %d).\n", GetLastError());
		return INVALID_HANDLE_VALUE;
	}

	return hDevice;
}

int SDCardWrite(HANDLE hDevice, unsigned int sec, unsigned int num_secs, const unsigned char* buf)
{
	LARGE_INTEGER pos;
	DWORD         cnt, wcnt;
	BOOL          bResult;

	pos.QuadPart = ((LONGLONG)sec) << 9;     // assume 512-byte sector
	cnt = ((DWORD)num_secs) << 9;

	bResult = SetFilePointerEx(hDevice, pos, NULL, FILE_BEGIN);
	if (!bResult)
	{
		printf("SetFilePointerEx() failed (err = %d).\n", GetLastError());
		return(-1);
	}

	bResult = WriteFile(hDevice, buf, cnt, &wcnt, NULL);
	if (!bResult || cnt != wcnt)
	{
		printf("WriteFile() failed (err = %d).\n", GetLastError());
		return(-1);
	}

	return(0);
}

void WriteToSDCard(const char* sdcard, const Buffer & buf)
{
	HANDLE h = SDCardOpen(sdcard);
	if (h != INVALID_HANDLE_VALUE)
	{
		SDCardWrite(h, 0, buf.GetSize() / 512, (const unsigned char *)buf.GetBaseAddr() );
		CloseHandle(h);
	}
}



int main( int argc, char * argv [] )
{
	Buffer src;
	if (argc < 3)
	{
		printf("Usage: ChecksumGen    <infile> <outfile>\n\n");
		printf("Usage: ChecksumGen -w <infile> <sdcard>\n");
		printf("                      write to SD Card directly\n\n");

		printf("Example:\n");
		printf("  arm-none-eabi-as.exe -o out.elf main.s\n");
		printf("  arm-none-eabi-objcopy.exe -O binary out.elf out.bin\n");
		printf("  ChecksumGen.exe out.bin out.raw\n\n");
		printf("  You should now be able to write out.raw to an SD card that will boot your device.\n");
		return 0;
	}

	int inFileIdx = 1;
	int outFileIdx = 2;
	bool writeToSDCard = false;

	if (!strcmp(argv[1], "-w"))
	{
		inFileIdx++;
		outFileIdx++;
		writeToSDCard = true;
	}

	FILE * fp = fopen(argv[inFileIdx], "rb");
	if (fp != nullptr)
	{
		src.Read(fp);
		fclose(fp);
	}
	else
	{
		printf( "Unable to open source file\n" );
		return 0;
	}

	Header * header = (Header *)(src.GetBaseAddr());
	src.SetBufSize(header->length);			// at this point, the buffer is the size of the image on disk, resize the buffer to the length value specified in the image (it could be larger).
	header = (Header *)(src.GetBaseAddr());	// re-assign the header just in case the base address changed during realloc
	header->check_sum = 0x5F0A6C39;
	header->check_sum = ComputeCheckSum(src);

	if (!writeToSDCard)
	{
		fp = fopen(argv[outFileIdx], "wb");
		if (fp != nullptr)
		{
			int size = src.WriteFATHeader(fp);
			src.Write(fp, 0x2000 - size);
			fclose(fp);
		}
		else
		{
			printf("Unable to open destination file\n");
			return 0;
		}
	}
	else
	{
		WriteToSDCard( argv[outFileIdx], src );
	}

	return 1;
}
