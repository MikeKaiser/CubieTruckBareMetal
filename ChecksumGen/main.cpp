// A20 Checksum Generator for Windows.
// by Mike Kaiser (11 Dec 2014) [no additional copyright from me. It's trivial stuff so take it and do what you like with it]
// This code has been inspired by many of the internet forum posts and GPL / LGPL code out there on various forums.
//
// The source of the header definition is directly from sunxi-tools/bootinfo.c
// (C) Copyright 2012 Henrik Nordstrom <henrik@henriknordstrom.net>
//
// Thanks go to Goatfreed on Cubieforums for posting his test program and instructions on how to get it running.
// Thanks to baremetal for suggesting a boot sector to stop windows bringing up an 'unformated' dialog.
// This code is provided without warranty and does not claim to be bug free or fit for any purpose. Use it at your own risk.


#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

typedef unsigned char  u8;
typedef unsigned short u16;
typedef unsigned int   u32;

typedef signed char  s8;
typedef signed short s16;
typedef signed int   s32;

class Buffer
{
	int bufLen;
	u8 * buf;

public:
	Buffer()
		: bufLen(0)
		, buf( nullptr )
	{
	}

	~Buffer()
	{
		if (buf)
			free(buf);
	}

	void Read(FILE * fp)
	{
		fseek(fp, 0, SEEK_END);
		bufLen = ftell(fp);
		fseek(fp, 0, SEEK_SET);
		buf = (u8 *)realloc(buf, bufLen);
		fread(buf, 1, bufLen, fp);
	}

	void Write(FILE * fp, int padSize)
	{
		char pad = 0;
		for (int i = 0; i < padSize; ++i)
			fwrite(&pad, 1, 1, fp);
		fwrite(buf, 1, bufLen, fp);
	}

	int WriteFATHeader(FILE * fp)
	{
		// This writes a bare minimum boot sector to fool windows into thinking it has a valid FAT16 disk
		u8 header[] =
		{
			// Jump
			0xEB, 0x3C, 0x90,
			
			// OEM ID
			0x4D, 0x53, 0x44, 0x4F, 0x53, 0x35, 0x2E, 0x30,

			// BPB and EBPB
			0x00, 0x02, 0x08, 0x04, 0x00, 0x02, 0x00, 0x02,	0x00, 0x00, 0xF8, 0xEE, 0x00, 0x3F, 0x00, 0xFF,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x07,	0x00, 0x80, 0x00, 0x29, 0x80, 0xE1, 0x4B, 0x38,
			0x4E, 0x4F, 0x20, 0x4E, 0x41, 0x4D, 0x45, 0x20,	0x20, 0x20, 0x20, 0x46, 0x41, 0x54, 0x31, 0x36,
			0x20, 0x20, 0x20, 0x33, 0xC9, 0x8E, 0xD1, 0xBC,	0xF0, 0x7B, 0x8E, 0xD9, 0xB8, 0x00, 0x20, 0x8E,
			0xC0, 0xFC, 0xBD, 0x00, 0x7C, 0x38, 0x4E, 0x24, 0x7D
		};

		fwrite(header, 1, sizeof(header), fp);

		for (int i = 0; i < 426; ++i)		// this would be were the code for the DOS boot sector would live but we just zero it out
			fputc(0, fp);

		fputc(0x55, fp);
		fputc(0xAA, fp);
		return 512;
	}

	void SetBufSize( int newSize )
	{
		int oldLen = bufLen;
		bufLen = newSize;
		buf = (u8*)realloc(buf, newSize);
		for (int i = oldLen; i < bufLen; ++i)
			buf[i] = 0xFF;
	}

	void * GetBaseAddr() const
	{
		return buf;
	}

	void * GetEndAddr() const
	{
		return buf + bufLen;
	}
};




struct Header
{
	u32		jump_instruction;	// one instruction jumping to real code
	char	magic[8];			// ="eGON.BT0" or "eGON.BT1", not C-style string.
	u32		check_sum;			// generated by PC
	u32		length;				// specified in your startup ASM
	u32		pub_head_size;		// the size of boot_file_head_t
	u8		pub_head_vsn[4];	// the version of boot_file_head_t
	u8		file_head_vsn[4];	// the version of boot0_file_head_t or boot1_file_head_t
	u8		Boot_vsn[4];		// Boot version
	u8		eGON_vsn[4];		// eGON version
	u8		platform[8];		// platform information
};



u32 ComputeCheckSum(const Buffer & src)
{
	u32 checksum = 0;
	u32 * ptr = (u32 *)(src.GetBaseAddr());
	u32 * end = (u32 *)(src.GetEndAddr());

	while(ptr < end)
	{
		checksum += *(ptr++);	// I'm sure there should be some bigendian / littleendian swapping going on here but it seems to work all the same. <Shrug>
	}

	return checksum;
}


int main( int argc, char * argv [] )
{
	Buffer src;
	if (argc < 3)
	{
		printf("Usage: ChecksumGen <infile> <outfile>\n\n");
		printf("Example:\n");
		printf("  arm-none-eabi-as.exe -o out.elf main.s\n");
		printf("  arm-none-eabi-objcopy.exe -O binary out.elf out.bin\n");
		printf("  ChecksumGen.exe out.bin out.raw\n\n");
		printf("  You should now be able to write out.raw to an SD card that will boot your device.\n");
		return 0;
	}

	FILE * fp = fopen(argv[1], "rb");
	if (fp != nullptr)
	{
		src.Read(fp);
		fclose(fp);
	}
	else
	{
		printf( "Unable to open source file\n" );
		return 0;
	}

	Header * header = (Header *)(src.GetBaseAddr());
	src.SetBufSize(header->length);			// at this point, the buffer is the size of the image on disk, resize the buffer to the length value specified in the image (it could be larger).
	header = (Header *)(src.GetBaseAddr());	// re-assign the header just in case the base address changed during realloc
	header->check_sum = 0x5F0A6C39;
	header->check_sum = ComputeCheckSum(src);


	fp = fopen(argv[2], "wb");
	if (fp != nullptr)
	{
		int size = src.WriteFATHeader(fp);
		src.Write(fp, 0x2000 - size);
		fclose(fp);
	}
	else
	{
		printf( "Unable to open destination file\n" );
		return 0;
	}

	return 1;
}
